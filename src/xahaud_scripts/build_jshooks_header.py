#!/usr/bin/env python3

import os
import re
import subprocess
import sys
import hashlib
from pathlib import Path

from xahaud_scripts.utils.paths import get_xahaud_root


def convert_js_to_carray(js_file):
    """
    Convert a JavaScript file to a C array using qjsc.
    Extracts just the hex bytes from the qjsc output.
    """
    try:
        # Check if qjsc exists
        qjsc_path = "./qjsc"
        if not os.path.exists(qjsc_path) or not os.access(qjsc_path, os.X_OK):
            print(f"Error: {qjsc_path} not found or not executable.", file=sys.stderr)
            sys.exit(1)

        # Run qjsc to compile the JavaScript file to C code
        result = subprocess.run(
            [qjsc_path, "-c", "-o", "/dev/stdout", js_file],
            capture_output=True,
            check=True
        )

        # Check if we have any output
        if not result.stdout:
            print(f"Error: qjsc produced no output for {js_file}", file=sys.stderr)
            sys.exit(1)

        # Convert to text and extract just the hex values
        output_text = result.stdout.decode('utf-8', errors='replace')

        # Extract hexadecimal values from the array definition
        # Looking for patterns like 0x43, 0x0c, etc.
        hex_values = re.findall(r'0x[0-9A-Fa-f]{2}', output_text)

        # Format them as 0xXXU for the C array
        c_array = ", ".join([f"{hex_val}U" for hex_val in hex_values])

        return c_array

    except subprocess.CalledProcessError as e:
        print(f"Error executing qjsc: {e}", file=sys.stderr)
        if e.stderr:
            print(f"stderr: {e.stderr.decode('utf-8', errors='replace')}", file=sys.stderr)
        sys.exit(1)

def main():
    # Get the script directory and set working directory
    working_dir = os.path.join(get_xahaud_root(), "src/test/app")
    os.chdir(working_dir)

    # Set up paths
    wasmjs_dir = "generated/qjsb"
    input_file = "SetJSHook_test.cpp"
    output_file = "SetJSHook_wasm.h"

    # Create cache directory
    cache_dir = os.path.expanduser("~/.cache/jshooks-header")
    Path(cache_dir).mkdir(parents=True, exist_ok=True)

    # Create output directory if it doesn't exist
    Path(wasmjs_dir).mkdir(parents=True, exist_ok=True)

    print(f"Processing {input_file} to generate {output_file}...")

    # Write header of output file
    with open(output_file, 'w') as f:
        f.write('''
//This file is generated by build_test_jshooks.py
#ifndef SETHOOK_JSWASM_INCLUDED
#define SETHOOK_JSWASM_INCLUDED
#include <map>
#include <stdint.h>
#include <string>
#include <vector>
namespace ripple {
namespace test {
std::map<std::string, std::vector<uint8_t>> jswasm = {''')

    # Check if input file exists
    if not os.path.exists(input_file):
        print(f"Error: Input file '{input_file}' not found.", file=sys.stderr)
        sys.exit(1)

    # Read input file content and convert newlines to form feeds as in the original script
    with open(input_file, 'r', encoding='utf-8') as f:
        content = f.read()

    content_with_form_feeds = content.replace('\n', '\f')

    # Get hooks using regex that matches the original bash script's grep command
    pattern = r'R"\[test\.hook\](.*?)\[test\.hook\]"'
    raw_matches = re.findall(pattern, content_with_form_feeds, re.DOTALL)

    if not raw_matches:
        print("Warning: No test hooks found in the input file.", file=sys.stderr)
        sys.exit(0)

    # Process the matches similar to the original bash script's sed commands
    processed_matches = []
    for match in raw_matches:
        # Remove the opening tag
        processed = re.sub(r'^\(', '', match)
        # Remove the closing tag and any trailing whitespace/form feeds
        processed = re.sub(r'\)[\f \t]*$', '/*end*/', processed)
        processed_matches.append(processed)

    counter = 0
    for hook_content in processed_matches:
        print(f"Processing hook {counter}...")

        # Generate hash of the content for caching
        content_hash = hashlib.sha256(hook_content.encode('utf-8')).hexdigest()
        cache_file = os.path.join(cache_dir, f"hook-{content_hash}.c_array")

        with open(output_file, 'a') as f:
            f.write(f"\n/* ==== WASM: {counter} ==== */\n")
            f.write('{ R"[test.hook](')

            # Remove the /*end*/ marker and convert form feeds back to newlines
            # This directly mimics: cat <<< "$line" | sed -E 's/.{7}$//g' | tr -d '\n' | tr '\f' '\n'
            clean_content = hook_content[:-7] if hook_content.endswith('/*end*/') else hook_content
            clean_content = clean_content.replace('\f', '\n')
            f.write(clean_content)

            f.write(')[test.hook]",\n{')

        # Check if this is a WebAssembly module
        wat_count = len(re.findall(r'\(module', hook_content))
        if wat_count > 0:
            print(f"Error: WebAssembly text format detected in hook {counter}", file=sys.stderr)
            sys.exit(1)

        # Check if we have a cached version
        if os.path.exists(cache_file):
            print(f"Using cached version for hook {counter}")
            with open(cache_file, 'r') as cache:
                c_array = cache.read()
                with open(output_file, 'a') as f:
                    f.write(c_array)
        else:
            print(f"Compiling hook {counter}...")
            # Generate JS file with form feeds converted back to newlines
            js_content = hook_content.replace('\f', '\n')
            js_file = os.path.join(wasmjs_dir, f"test-{counter}-gen.js")
            with open(js_file, 'w', encoding='utf-8') as f:
                f.write(js_content)

            try:
                # Use our internal function instead of the external script
                c_array_output = convert_js_to_carray(js_file)

                # Cache the result
                with open(cache_file, 'w') as cache:
                    cache.write(c_array_output)

                # Write to output file
                with open(output_file, 'a') as f:
                    f.write(c_array_output)
            except Exception as e:
                print(f"Compilation error for hook {counter}: {e}", file=sys.stderr)
                sys.exit(1)

        with open(output_file, 'a') as f:
            f.write('}},\n\n')

        counter += 1

    # Write footer of output file
    with open(output_file, 'a') as f:
        f.write('''};
}
}
#endif''')

    # Format the output file using clang-format
    print("Formatting output file...")
    try:
        subprocess.run(["clang-format", "-i", output_file], check=True)
        print(f"Successfully generated {output_file} with {counter} hooks")
    except subprocess.CalledProcessError:
        print("Warning: clang-format failed, output might not be properly formatted", file=sys.stderr)
    except FileNotFoundError:
        print("Warning: clang-format not found, output will not be formatted", file=sys.stderr)

if __name__ == "__main__":
    main()
